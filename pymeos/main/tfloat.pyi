from pymeos_cffi import *
from ..collections import *
from ..boxes import TBox as TBox
from ..mixins import TSimplifiable as TSimplifiable, TTemporallyComparable as TTemporallyComparable
from ..temporal import TInstant as TInstant, TInterpolation as TInterpolation, TSequence as TSequence, TSequenceSet as TSequenceSet, Temporal as Temporal
from .tbool import TBool as TBool
from .tint import TInt as TInt
from .tnumber import TNumber as TNumber
from _typeshed import Incomplete
from abc import ABC
from typing import TypeVar, overload

Self = TypeVar('Self', bound='TFloat')

class TFloat(TNumber[float, 'TFloat', 'TFloatInst', 'TFloatSeq', 'TFloatSeqSet'], TSimplifiable, TTemporallyComparable, ABC):
    BaseClass = float
    @staticmethod
    def from_base_temporal(value: float, base: Temporal, interpolation: TInterpolation = ...) -> TFloat: ...
    @staticmethod
    @overload
    def from_base_time(value: float, base: datetime, interpolation: None = None) -> TFloatInst: ...
    @staticmethod
    @overload
    def from_base_time(value: float, base: TsTzSet, interpolation: None = None) -> TFloatSeq: ...
    @staticmethod
    @overload
    def from_base_time(value: float, base: TsTzSpan, interpolation: TInterpolation = None) -> TFloatSeq: ...
    @staticmethod
    @overload
    def from_base_time(value: float, base: TsTzSpanSet, interpolation: TInterpolation = None) -> TFloatSeqSet: ...
    @classmethod
    def from_mfjson(cls, mfjson: str) -> Self: ...
    def as_wkt(self, max_decimals: int = 15) -> str: ...
    def to_tint(self) -> TInt: ...
    def to_floatrange(self) -> FloatSpan: ...
    def value_span(self) -> FloatSpan: ...
    def value_spans(self) -> FloatSpanSet: ...
    def start_value(self) -> float: ...
    def end_value(self) -> float: ...
    def value_set(self) -> set[float]: ...
    def min_value(self) -> float: ...
    def max_value(self) -> float: ...
    def always_less(self, value: float | TFloat) -> bool: ...
    def always_less_or_equal(self, value: float | TFloat) -> bool: ...
    def always_equal(self, value: float | TFloat) -> bool: ...
    def always_not_equal(self, value: float | TFloat) -> bool: ...
    def always_greater_or_equal(self, value: float | TFloat) -> bool: ...
    def always_greater(self, value: float | TFloat) -> bool: ...
    def ever_less(self, value: float | TFloat) -> bool: ...
    def ever_less_or_equal(self, value: float | TFloat) -> bool: ...
    def ever_equal(self, value: float | TFloat) -> bool: ...
    def ever_not_equal(self, value: float | TFloat) -> bool: ...
    def ever_greater_or_equal(self, value: float | TFloat) -> bool: ...
    def ever_greater(self, value: float | TFloat) -> bool: ...
    def never_less(self, value: float | TFloat) -> bool: ...
    def never_less_or_equal(self, value: float | TFloat) -> bool: ...
    def never_equal(self, value: float | TFloat) -> bool: ...
    def never_not_equal(self, value: float | TFloat) -> bool: ...
    def never_greater_or_equal(self, value: float | TFloat) -> bool: ...
    def never_greater(self, value: float | TFloat) -> bool: ...
    def temporal_equal(self, other: int | float | TFloat) -> TBool: ...
    def temporal_not_equal(self, other: int | float | TFloat) -> TBool: ...
    def temporal_less(self, other: int | float | TFloat) -> TBool: ...
    def temporal_less_or_equal(self, other: int | float | TFloat) -> TBool: ...
    def temporal_greater_or_equal(self, other: int | float | TFloat) -> TBool: ...
    def temporal_greater(self, other: int | float | TFloat) -> TBool: ...
    def at(self, other: float | int | FloatSet | IntSet | FloatSpan | IntSpan | FloatSpanSet | IntSpanSet | TBox | Time) -> TFloat: ...
    def minus(self, other: float | int | FloatSet | IntSet | FloatSpan | IntSpan | FloatSpanSet | IntSpanSet | TBox | Time) -> Temporal: ...
    def value_at_timestamp(self, timestamp) -> float: ...
    def derivative(self) -> TFloat: ...
    def to_degrees(self, normalize: bool = True) -> TFloat: ...
    def to_radians(self) -> TFloat: ...
    def round(self, max_decimals: int = 0) -> TFloat: ...
    def value_split(self, size: float, start: float | None = 0) -> list[Temporal]: ...
    def value_time_split(self, value_size: float, duration: str | timedelta, value_start: float | None = 0.0, time_start: str | datetime | None = None) -> list[Temporal]: ...
    @staticmethod
    def read_from_cursor(value, _: Incomplete | None = None): ...

class TFloatInst(TInstant[float, 'TFloat', 'TFloatInst', 'TFloatSeq', 'TFloatSeqSet'], TFloat):
    def __init__(self, string: str | None = None, *, value: str | float | None = None, timestamp: str | datetime | None = None, _inner: Incomplete | None = None) -> None: ...

class TFloatSeq(TSequence[float, 'TFloat', 'TFloatInst', 'TFloatSeq', 'TFloatSeqSet'], TFloat):
    ComponentClass = TFloatInst
    def __init__(self, string: str | None = None, *, instant_list: list[str | TFloatInst] | None = None, lower_inc: bool = True, upper_inc: bool = False, interpolation: TInterpolation = ..., normalize: bool = True, _inner: Incomplete | None = None) -> None: ...

class TFloatSeqSet(TSequenceSet[float, 'TFloat', 'TFloatInst', 'TFloatSeq', 'TFloatSeqSet'], TFloat):
    ComponentClass = TFloatSeq
    def __init__(self, string: str | None = None, *, sequence_list: list[str | TFloatSeq] | None = None, normalize: bool = True, _inner: Incomplete | None = None) -> None: ...
