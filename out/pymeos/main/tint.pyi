from pymeos_cffi import *
from ..collections import *
from ..boxes import TBox as TBox
from ..mixins import TTemporallyComparable as TTemporallyComparable
from ..temporal import (
    TInstant as TInstant,
    TInterpolation as TInterpolation,
    TSequence as TSequence,
    TSequenceSet as TSequenceSet,
    Temporal as Temporal,
)
from .tbool import TBool as TBool
from .tfloat import TFloat as TFloat
from .tnumber import TNumber as TNumber
from _typeshed import Incomplete
from abc import ABC
from typing import TypeVar, overload

Self = TypeVar("Self", bound="TInt")

class TInt(
    TNumber[int, "TInt", "TIntInst", "TIntSeq", "TIntSeqSet"],
    TTemporallyComparable,
    ABC,
):
    BaseClass = int
    @staticmethod
    def from_base_temporal(value: int, base: Temporal) -> TInt: ...
    @staticmethod
    @overload
    def from_base_time(value: int, base: datetime) -> TIntInst: ...
    @staticmethod
    @overload
    def from_base_time(value: int, base: TsTzSet | TsTzSpan) -> TIntSeq: ...
    @staticmethod
    @overload
    def from_base_time(value: int, base: TsTzSpanSet) -> TIntSeqSet: ...
    @classmethod
    def from_mfjson(cls, mfjson: str) -> Self: ...
    def as_wkt(self): ...
    def to_tfloat(self) -> TFloat: ...
    def to_intspan(self) -> IntSpan: ...
    def value_span(self) -> IntSpan: ...
    def value_spans(self) -> IntSpanSet: ...
    def start_value(self) -> int: ...
    def end_value(self) -> int: ...
    def value_set(self) -> set[int]: ...
    def min_value(self) -> int: ...
    def max_value(self) -> int: ...
    def value_at_timestamp(self, timestamp) -> int: ...
    def always_less(self, value: int | TInt) -> bool: ...
    def always_less_or_equal(self, value: int | TInt) -> bool: ...
    def always_equal(self, value: int | TInt) -> bool: ...
    def always_not_equal(self, value: int | TInt) -> bool: ...
    def always_greater_or_equal(self, value: int | TInt) -> bool: ...
    def always_greater(self, value: int | TInt) -> bool: ...
    def ever_less(self, value: int | TInt) -> bool: ...
    def ever_less_or_equal(self, value: int | TInt) -> bool: ...
    def ever_equal(self, value: int | TInt) -> bool: ...
    def ever_not_equal(self, value: int | TInt) -> bool: ...
    def ever_greater_or_equal(self, value: int | TInt) -> bool: ...
    def ever_greater(self, value: int | TInt) -> bool: ...
    def never_less(self, value: int | TInt) -> bool: ...
    def never_less_or_equal(self, value: int | TInt) -> bool: ...
    def never_equal(self, value: int | TInt) -> bool: ...
    def never_not_equal(self, value: int | TInt) -> bool: ...
    def never_greater_or_equal(self, value: int | TInt) -> bool: ...
    def never_greater(self, value: int | TInt) -> bool: ...
    def temporal_equal(self, other: int | TInt) -> TBool: ...
    def temporal_not_equal(self, other: int | TInt) -> TBool: ...
    def temporal_less(self, other: int | TInt) -> TBool: ...
    def temporal_less_or_equal(self, other: int | TInt) -> TBool: ...
    def temporal_greater_or_equal(self, other: int | TInt) -> TBool: ...
    def temporal_greater(self, other: int | TInt) -> TBool: ...
    def at(
        self,
        other: (
            int
            | float
            | IntSet
            | FloatSet
            | IntSpan
            | FloatSpan
            | IntSpanSet
            | FloatSpanSet
            | TBox
            | Time
        ),
    ) -> TInt: ...
    def minus(
        self,
        other: (
            int
            | float
            | IntSet
            | FloatSet
            | IntSpan
            | FloatSpan
            | IntSpanSet
            | FloatSpanSet
            | TBox
            | Time
        ),
    ) -> TInt: ...
    def nearest_approach_distance(
        self, other: int | float | TNumber | TBox
    ) -> float: ...
    def value_split(self, size: int, start: int | None = 0) -> list[TInt]: ...
    def value_time_split(
        self,
        value_size: int,
        duration: str | timedelta,
        value_start: int | None = 0,
        time_start: str | datetime | None = None,
    ) -> list[TInt]: ...
    @staticmethod
    def read_from_cursor(value, _: Incomplete | None = None): ...

class TIntInst(TInstant[int, "TInt", "TIntInst", "TIntSeq", "TIntSeqSet"], TInt):
    def __init__(
        self,
        string: str | None = None,
        *,
        value: str | int | None = None,
        timestamp: str | datetime | None = None,
        _inner: Incomplete | None = None,
    ) -> None: ...

class TIntSeq(TSequence[int, "TInt", "TIntInst", "TIntSeq", "TIntSeqSet"], TInt):
    ComponentClass = TIntInst
    def __init__(
        self,
        string: str | None = None,
        *,
        instant_list: list[str | TIntInst] | None = None,
        lower_inc: bool = True,
        upper_inc: bool = False,
        interpolation: TInterpolation = ...,
        normalize: bool = True,
        _inner: Incomplete | None = None,
    ) -> None: ...

class TIntSeqSet(TSequenceSet[int, "TInt", "TIntInst", "TIntSeq", "TIntSeqSet"], TInt):
    ComponentClass = TIntSeq
    def __init__(
        self,
        string: str | None = None,
        *,
        sequence_list: list[str | TIntSeq] | None = None,
        normalize: bool = True,
        _inner: Incomplete | None = None,
    ) -> None: ...
